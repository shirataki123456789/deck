import streamlit as st
import pandas as pd
import json
import os
import qrcode
from PIL import Image, ImageDraw, ImageFont
import io
import base64
import re 
import requests 
from io import BytesIO 
from concurrent.futures import ThreadPoolExecutor, as_completed

# ===============================
# üß† „Ç≠„É£„ÉÉ„Ç∑„É•‰ªò„Åç„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
# ===============================
@st.cache_data(ttl=3600, show_spinner=False)
def load_data():
    if not os.path.exists("cardlist_filtered.csv"):
        st.error("„Ç®„É©„Éº: cardlist_filtered.csv „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ")
        return pd.DataFrame()
        
    df = pd.read_csv("cardlist_filtered.csv")
    df = df.fillna("-")
    
    # ÁâπÂæ¥„Å®Â±ûÊÄß„ÅÆÂá¶ÁêÜ„ÇíÁµ±‰∏ÄÔºàÂÖ®Ëßí/ÂçäËßí„Çπ„É©„ÉÉ„Ç∑„É•ÂØæÂøúÔºâ
    df["ÁâπÂæ¥„É™„Çπ„Éà"] = df["ÁâπÂæ¥"].apply(lambda x: [f.strip() for f in str(x).replace("Ôºè", "/").split("/") if f.strip() and f.strip() != "-"])
    df["Â±ûÊÄß„É™„Çπ„Éà"] = df["Â±ûÊÄß"].apply(lambda x: [f.strip() for f in str(x).replace("Ôºè", "/").split("/") if f.strip() and f.strip() != "-"])
    df["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"] = df["„Ç≥„Çπ„Éà"].replace("-", 0).astype(int)
    
    # ‰øÆÊ≠£: ÂÖ•ÊâãÊÉÖÂ†±„Åã„Çâ„Äê„ÄëÂÜÖ„ÅÆ„Ç∑„É™„Éº„Ç∫Áï™Âè∑„ÅÆ„Åø„ÇíÊäΩÂá∫
    def extract_series_id(info):
        match = re.search(r'„Äê(.*?)„Äë', str(info))
        if match:
            return match.group(1).strip()
        return "„Åù„ÅÆ‰ªñ" if str(info).strip() not in ["-", ""] else "-"
        
    df["„Ç∑„É™„Éº„Ç∫ID"] = df["ÂÖ•ÊâãÊÉÖÂ†±"].apply(extract_series_id)
    
    return df

df = load_data()
if df.empty:
    st.stop()

# ÁÑ°Âà∂Èôê„Ç´„Éº„Éâ„ÅÆ„É™„Çπ„Éà
UNLIMITED_CARDS = ["OP01-075", "OP08-072"]

# ===============================
# üß© ‰∏¶„Å≥È†ÜË®≠ÂÆö
# ===============================
color_order = ["Ëµ§", "Á∑ë", "Èùí", "Á¥´", "Èªí", "ÈªÑ"]
color_priority = {c: i for i, c in enumerate(color_order)}
type_priority = {"LEADER": 0, "CHARACTER": 1, "EVENT": 2, "STAGE": 3}

def color_sort_key(row):
    text = str(row["Ëâ≤"])
    t = str(row["„Çø„Ç§„Éó"])
    if text.strip() == "-" or text.strip() == "":
        return (999, 999, 999, 999)

    found_colors = [c for c in color_order if c in text]
    if not found_colors:
        return (999, 999, 999, 999)

    first_color = found_colors[0]
    base_priority = color_priority[first_color]

    is_multi = "/" in text or "Ôºè" in text
    sub_colors = [c for c in color_order if c in text and c != first_color]
    sub_priority = color_order.index(sub_colors[0]) + 1 if is_multi and sub_colors else 0
    multi_flag = 1 if is_multi else 0

    type_rank = type_priority.get(t, 9)
    return (base_priority, type_rank, sub_priority, multi_flag)

df["„ÇΩ„Éº„Éà„Ç≠„Éº"] = df.apply(color_sort_key, axis=1)

# ===============================
# üíæ „Çª„ÉÉ„Ç∑„Éß„É≥ÂàùÊúüÂåñ
# ===============================
if "leader" not in st.session_state:
    st.session_state["leader"] = None
if "deck" not in st.session_state:
    st.session_state["deck"] = {}
if "mode" not in st.session_state:
    st.session_state["mode"] = "Ê§úÁ¥¢"
if "deck_view" not in st.session_state:
    st.session_state["deck_view"] = "leader"
if "deck_name" not in st.session_state:
    st.session_state["deck_name"] = ""
if "search_cols" not in st.session_state: 
    st.session_state["search_cols"] = 3
if "qr_upload_key" not in st.session_state: 
    st.session_state["qr_upload_key"] = 0
    
# „Éá„ÉÉ„Ç≠ËøΩÂä†ÁîªÈù¢Áî®„ÅÆ„Éï„Ç£„É´„ÇøÁä∂ÊÖã„ÇíÂàùÊúüÂåñ
if "deck_filter" not in st.session_state:
    st.session_state["deck_filter"] = {
        "colors": [],
        "types": [], # üí° ‰øÆÊ≠£: ÂàùÊúüÈÅ∏Êäû„ÇíÁ©∫„É™„Çπ„Éà„Å´Â§âÊõ¥
        "costs": [],
        "counters": [],
        "attributes": [],
        "blocks": [],
        "features": [],
        "series_ids": [],
        "free_words": ""
    }

# ===============================
# üîç Ê§úÁ¥¢Èñ¢Êï∞
# ===============================
def filter_cards(df, colors, types, costs, counters, attributes, blocks, feature_selected, free_words, series_ids=None, leader_colors=None):
    results = df.copy()

    # „Éá„ÉÉ„Ç≠‰ΩúÊàê„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÄÅ„É™„Éº„ÉÄ„Éº„ÅÆËâ≤„Å´Âü∫„Å•„ÅÑ„Å¶„Éï„Ç£„É´„Çø
    if leader_colors:
        results = results[results["„Çø„Ç§„Éó"] != "LEADER"]
        results = results[results["Ëâ≤"].apply(lambda c: any(lc in c for lc in leader_colors))]

    if colors:
        results = results[results["Ëâ≤"].apply(lambda c: any(col in c for col in colors))]

    if types:
        results = results[results["„Çø„Ç§„Éó"].isin(types)]

    if costs:
        results = results[results["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"].isin(costs)]

    if counters:
        results = results[results["„Ç´„Ç¶„É≥„Çø„Éº"].isin(counters)]

    if attributes:
        results = results[results["Â±ûÊÄß„É™„Çπ„Éà"].apply(lambda lst: any(attr in lst for attr in attributes))]

    if blocks:
        results = results[results["„Éñ„É≠„ÉÉ„ÇØ„Ç¢„Ç§„Ç≥„É≥"].isin(blocks)]
        
    # „Ç∑„É™„Éº„Ç∫ID„Éï„Ç£„É´„Çø
    if series_ids:
        results = results[results["„Ç∑„É™„Éº„Ç∫ID"].isin(series_ids)]

    if feature_selected:
        results = results[results["ÁâπÂæ¥„É™„Çπ„Éà"].apply(lambda lst: any(f in lst for f in feature_selected))]

    if free_words:
        keywords = free_words.split()
        for k in keywords:
            results = results[
                results["„Ç´„Éº„ÉâÂêç"].str.contains(k, case=False, na=False) |
                results["ÁâπÂæ¥"].str.contains(k, case=False, na=False) |
                results["„ÉÜ„Ç≠„Çπ„Éà"].str.contains(k, case=False, na=False) |
                results["„Éà„É™„Ç¨„Éº"].str.contains(k, case=False, na=False)
            ]

    results = results.sort_values(
        by=["„ÇΩ„Éº„Éà„Ç≠„Éº", "„Ç≥„Çπ„ÉàÊï∞ÂÄ§", "„Ç´„Éº„ÉâID"], ascending=[True, True, True]
    )
    return results

# ===============================
# üñºÔ∏è „Éá„ÉÉ„Ç≠ÁîªÂÉèÁîüÊàêÈñ¢Êï∞ 
# ===============================
@st.cache_data(ttl=3600, show_spinner=False) 
def create_deck_image(leader, deck_dict, df, deck_name=""):
    """„Éá„ÉÉ„Ç≠„É™„Çπ„Éà„ÅÆÁîªÂÉè„ÇíÁîüÊàêÔºà„Ç´„Éº„ÉâÁîªÂÉèÔºãQR„Ç≥„Éº„Éâ‰ªò„ÅçÔºâ2150x2048Âõ∫ÂÆö„Çµ„Ç§„Ç∫"""
    
    # ÊúÄÁµÇÁîªÂÉè„Çµ„Ç§„Ç∫
    FINAL_WIDTH = 2150
    FINAL_HEIGHT = 2048
    
    # „Ç´„Éº„Éâ„Ç∞„É™„ÉÉ„Éâ„ÅÆÈ´ò„Åï 
    GRID_HEIGHT = 1500 
    
    # ‰∏ä„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆÊúÄÂ§ßÈ´ò„Åï
    UPPER_HEIGHT = FINAL_HEIGHT - GRID_HEIGHT
    
    # „É™„Éº„ÉÄ„Éº„ÅÆËâ≤„ÇíÂèñÂæó
    leader_color_text = leader["Ëâ≤"]
    leader_colors = [c.strip() for c in leader_color_text.replace("Ôºè", "/").split("/") if c.strip()]
    
    # Ëâ≤„Åã„ÇâËÉåÊôØËâ≤„ÇíÂèñÂæó 
    color_map = {
        "Ëµ§": "#AC1122", "Á∑ë": "#008866", "Èùí": "#0084BD", 
        "Á¥´": "#93388B", "Èªí": "#211818", "ÈªÑ": "#F7E731"
    }
    
    # „Éá„ÉÉ„Ç≠„É™„Çπ„Éà„ÉÜ„Ç≠„Çπ„ÉàÁîüÊàê
    deck_lines = []
    if deck_name:
        deck_lines.append(f"# {deck_name}")
    deck_lines.append(f"1x{leader['„Ç´„Éº„ÉâID']}")
    
    deck_cards_sorted = []
    for card_id, count in deck_dict.items():
        card_row = df[df["„Ç´„Éº„ÉâID"] == card_id].iloc[0]
        base_priority, type_rank, sub_priority, multi_flag = card_row["„ÇΩ„Éº„Éà„Ç≠„Éº"]
        deck_cards_sorted.append({
            "card_id": card_id,
            "count": count,
            "new_sort_key": (type_rank, card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"], base_priority, card_id), 
            "cost": card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"]
        })
    deck_cards_sorted.sort(key=lambda x: x["new_sort_key"])
    
    for card_info in deck_cards_sorted:
        deck_lines.append(f"{card_info['count']}x{card_info['card_id']}")
    deck_text = "\n".join(deck_lines)
    
    # QR„Ç≥„Éº„ÉâÁîüÊàê
    qr = qrcode.QRCode(version=1, box_size=8, border=2)
    qr.add_data(deck_text)
    qr.make(fit=True)
    qr_img = qr.make_image(fill_color="black", back_color="white")
    QR_SIZE = 400
    qr_img = qr_img.resize((QR_SIZE, QR_SIZE), Image.LANCZOS)
    
    # „Ç´„Éº„ÉâÁîªÂÉè„ÅÆ„Çµ„Ç§„Ç∫Ôºà‰∏ãÈÉ®„Ç∞„É™„ÉÉ„ÉâÁî®Ôºâ
    card_width = 215
    card_height = 300
    cards_per_row = 10
    cards_per_col = 5
    margin_card = 0
    
    # ÁîªÂÉè‰ΩúÊàê (RGBA„É¢„Éº„Éâ„ÅßÂàùÊúüÂåñ)
    img = Image.new('RGBA', (FINAL_WIDTH, FINAL_HEIGHT), (255, 255, 255, 255))
    draw = ImageDraw.Draw(img)
    
    # ËÉåÊôØËâ≤Ôºà„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ÂØæÂøúÔºâ
    if len(leader_colors) == 1:
        bg_color = color_map.get(leader_colors[0], "#FFFFFF")
        draw.rectangle([0, 0, FINAL_WIDTH, FINAL_HEIGHT], fill=bg_color)
    elif len(leader_colors) >= 2:
        color1 = color_map.get(leader_colors[0], "#FFFFFF")
        color2 = color_map.get(leader_colors[1], "#FFFFFF")
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        rgb1, rgb2 = hex_to_rgb(color1), hex_to_rgb(color2)

        for x in range(FINAL_WIDTH):
            ratio = x / FINAL_WIDTH
            r = int(rgb1[0] * (1 - ratio) + rgb2[0] * ratio)
            g = int(rgb1[1] * (1 - ratio) + rgb2[1] * ratio)
            b = int(rgb1[2] * (1 - ratio) + rgb2[2] * ratio)
            draw.line([(x, 0), (x, FINAL_HEIGHT)], fill=(r, g, b))
    
    # ÁîªÂÉè„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñ¢Êï∞
    def download_card_image(card_id, target_size, crop_top_half=False):
        try:
            card_url = f"https://www.onepiece-cardgame.com/images/cardlist/card/{card_id}.png"
            response = requests.get(card_url, timeout=5)
            if response.status_code == 200:
                card_img = Image.open(BytesIO(response.content)).convert("RGBA")
                
                if crop_top_half:
                    CROPPED_WIDTH = target_size[0]
                    CROPPED_HEIGHT = target_size[1]
                    
                    full_height_target = CROPPED_HEIGHT * 2 
                    card_img = card_img.resize((CROPPED_WIDTH, full_height_target), Image.LANCZOS)
                    
                    card_img = card_img.crop((0, 0, CROPPED_WIDTH, CROPPED_HEIGHT))
                else:
                    card_img = card_img.resize(target_size, Image.LANCZOS) 
                    
                return card_id, card_img
        except Exception as e:
            return card_id, None

    # --- ‰∏ä„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆÈÖçÁΩÆÔºà„É™„Éº„ÉÄ„Éº ‚Üí „Éá„ÉÉ„Ç≠Âêç ‚Üí QRÔºâ ---
    
    GAP = 48 
    
    LEADER_CROPPED_HEIGHT = UPPER_HEIGHT 
    LEADER_CROPPED_WIDTH = int(LEADER_CROPPED_HEIGHT * (400 / 280)) 
    LEADER_TARGET_SIZE = (LEADER_CROPPED_WIDTH, LEADER_CROPPED_HEIGHT) 
    
    QR_SIZE = 400
    
    DECK_NAME_AREA_WIDTH = FINAL_WIDTH - (GAP * 3) - LEADER_CROPPED_WIDTH - QR_SIZE 

    leader_x = GAP 
    deck_name_area_start_x = leader_x + LEADER_CROPPED_WIDTH + GAP 
    qr_x = deck_name_area_start_x + DECK_NAME_AREA_WIDTH + GAP 
    
    leader_y = 0 
    qr_y = (UPPER_HEIGHT - QR_SIZE) // 2 

    # 1. „É™„Éº„ÉÄ„ÉºÁîªÂÉè„ÇíÈÖçÁΩÆ 
    try:
        _, leader_img = download_card_image(leader['„Ç´„Éº„ÉâID'], LEADER_TARGET_SIZE, crop_top_half=True) 
        if leader_img:
            img.paste(leader_img, (leader_x, leader_y), leader_img) 
    except:
        pass

    # 3. QR„Ç≥„Éº„Éâ„ÇíÈÖçÁΩÆ 
    img.paste(qr_img.convert("RGBA"), (qr_x, qr_y), qr_img.convert("RGBA"))
    
    # 2. „Éá„ÉÉ„Ç≠ÂêçÔºà‰∏≠Â§ÆÔºâ
    if deck_name:
        try:
            FONT_SIZE = 70 
            import platform
            system = platform.system()
            if system == "Windows":
                font_name = ImageFont.truetype("msgothic.ttc", FONT_SIZE)
            elif system == "Darwin":
                font_name = ImageFont.truetype("/System/Library/Fonts/„Éí„É©„ÇÆ„ÉéËßí„Ç¥„Ç∑„ÉÉ„ÇØ W3.ttc", FONT_SIZE)
            else:
                font_name = ImageFont.truetype("/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc", FONT_SIZE)
        except:
            try:
                font_name = ImageFont.truetype("arial.ttf", FONT_SIZE)
            except:
                font_name = ImageFont.load_default()
        
        bbox = draw.textbbox((0, 0), deck_name, font=font_name)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]
        
        BG_HEIGHT = text_height + 40 
        bg_x1 = deck_name_area_start_x + 50 
        bg_x2 = deck_name_area_start_x + DECK_NAME_AREA_WIDTH - 50
        bg_y1 = (UPPER_HEIGHT - BG_HEIGHT) // 2
        bg_y2 = bg_y1 + BG_HEIGHT

        overlay = Image.new('RGBA', (FINAL_WIDTH, FINAL_HEIGHT), (0, 0, 0, 0))
        overlay_draw = ImageDraw.Draw(overlay)
        overlay_draw.rectangle([bg_x1, bg_y1, bg_x2, bg_y2], fill=(0, 0, 0, 128))
        
        img = Image.alpha_composite(img, overlay)
        draw = ImageDraw.Draw(img) 

        text_x = bg_x1 + (bg_x2 - bg_x1 - text_width) // 2
        text_y = bg_y1 + 20 

        draw.text((text_x, text_y), deck_name, fill="white", font=font_name)
    
    # ‰∏ã„Çª„ÇØ„Ç∑„Éß„É≥Ôºö„Éá„ÉÉ„Ç≠„Ç´„Éº„ÉâÔºà10x5„Ç∞„É™„ÉÉ„ÉâÔºâ
    y_start = UPPER_HEIGHT 
    x_start = (FINAL_WIDTH - (card_width * cards_per_row + margin_card * (cards_per_row - 1))) // 2
    
    all_deck_cards = []
    for card_info in deck_cards_sorted:
        all_deck_cards.extend([card_info['card_id']] * card_info['count'])
    
    card_images = {}
    cards_to_download = set(all_deck_cards[:cards_per_row * cards_per_col])
    
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = {executor.submit(download_card_image, card_id, (card_width, card_height)): card_id 
                   for card_id in cards_to_download}
        
        for future in as_completed(futures):
            card_id, card_img = future.result()
            if card_img:
                card_images[card_id] = card_img
    
    for idx, card_id in enumerate(all_deck_cards):
        if idx >= cards_per_row * cards_per_col:
            break
        
        row = idx // cards_per_row
        col = idx % cards_per_row
        
        x = x_start + col * (card_width + margin_card)
        y = y_start + row * (card_height + margin_card)
        
        if card_id in card_images:
            img.paste(card_images[card_id], (x, y), card_images[card_id])
    
    return img.convert('RGB')

# ===============================
# üéØ „É¢„Éº„ÉâÂàáÊõø
# ===============================
st.sidebar.title("üéØ „É¢„Éº„ÉâÈÅ∏Êäû")

def set_mode_on_change():
    selected_label = st.session_state["mode_radio_key"]
    st.session_state["mode"] = "Ê§úÁ¥¢" if "Ê§úÁ¥¢" in selected_label else "„Éá„ÉÉ„Ç≠"

mode_labels = ["üîç „Ç´„Éº„ÉâÊ§úÁ¥¢", "üß± „Éá„ÉÉ„Ç≠‰ΩúÊàê"]
current_index = 0 if st.session_state["mode"] == "Ê§úÁ¥¢" else 1

st.sidebar.radio(
    "„É¢„Éº„Éâ", 
    mode_labels, 
    index=current_index, 
    key="mode_radio_key", 
    on_change=set_mode_on_change, 
    label_visibility="collapsed"
)

# ===============================
# üîç „Ç´„Éº„ÉâÊ§úÁ¥¢„É¢„Éº„Éâ (‰øÆÊ≠£ÁÆáÊâÄ„Å™„Åó)
# ===============================
if st.session_state["mode"] == "Ê§úÁ¥¢":
    st.title("üîç „Ç´„Éº„ÉâÊ§úÁ¥¢")
    
    # --- Ê§úÁ¥¢„Éï„Ç£„É´„ÇøÔºà„Çµ„Ç§„Éâ„Éê„ÉºÔºâ ---
    st.sidebar.markdown("---")
    st.sidebar.subheader("Ê§úÁ¥¢„Éï„Ç£„É´„Çø")
    
    colors = st.sidebar.multiselect("Ëâ≤„ÇíÈÅ∏Êäû", color_order, key="search_colors")
    types = st.sidebar.multiselect("„Çø„Ç§„Éó„ÇíÈÅ∏Êäû", list(type_priority.keys()), key="search_types")
    costs = st.sidebar.multiselect("„Ç≥„Çπ„Éà„ÇíÈÅ∏Êäû", sorted(df["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"].unique()), key="search_costs")
    counters = st.sidebar.multiselect("„Ç´„Ç¶„É≥„Çø„Éº„ÇíÈÅ∏Êäû", sorted(df["„Ç´„Ç¶„É≥„Çø„Éº"].unique()), key="search_counters")
    
    all_attributes = sorted({attr for lst in df["Â±ûÊÄß„É™„Çπ„Éà"] for attr in lst if attr})
    attributes = st.sidebar.multiselect("Â±ûÊÄß„ÇíÈÅ∏Êäû", all_attributes, key="search_attributes")
    
    blocks = st.sidebar.multiselect("„Éñ„É≠„ÉÉ„ÇØ„Ç¢„Ç§„Ç≥„É≥", sorted(df["„Éñ„É≠„ÉÉ„ÇØ„Ç¢„Ç§„Ç≥„É≥"].unique()), key="search_blocks")
    
    all_features = sorted({f for lst in df["ÁâπÂæ¥„É™„Çπ„Éà"] for f in lst if f})
    feature_selected = st.sidebar.multiselect("ÁâπÂæ¥„ÇíÈÅ∏Êäû", all_features, key="search_features")
    
    # „Ç∑„É™„Éº„Ç∫ID„Éï„Ç£„É´„Çø 
    all_series_ids = sorted([s for s in df["„Ç∑„É™„Éº„Ç∫ID"].unique() if s != "-"])
    series_ids = st.sidebar.multiselect("ÂÖ•Êâã„Ç∑„É™„Éº„Ç∫„ÇíÈÅ∏Êäû", all_series_ids, key="search_series_ids")

    # „Éï„É™„Éº„ÉØ„Éº„ÉâÊ§úÁ¥¢
    free_words = st.sidebar.text_input("„Éï„É™„Éº„ÉØ„Éº„ÉâÊ§úÁ¥¢Ôºà„Çπ„Éö„Éº„ÇπÂå∫Âàá„ÇäÂèØÔºâ", key="search_free")
    
    # --- Ê§úÁ¥¢„É≠„Ç∏„ÉÉ„ÇØ (Â∏∏„Å´ÂÆüË°å) ---
    st.session_state["search_results"] = filter_cards(
        df, colors, types, costs, counters, attributes, blocks, feature_selected, free_words, series_ids=series_ids
    )
    
    results = st.session_state["search_results"]
    
    # Ë©≤ÂΩì„Ç´„Éº„ÉâÊï∞Ë°®Á§∫
    st.write(f"Ë©≤ÂΩì„Ç´„Éº„ÉâÊï∞Ôºö{len(results)} Êûö")
    
    # --- Ê§úÁ¥¢ÁµêÊûúË°®Á§∫ ---
    selected_cols = st.sidebar.selectbox( 
        "1Âàó„ÅÇ„Åü„Çä„ÅÆ„Ç´„Éº„ÉâÊï∞", 
        [3, 4, 5], 
        index=[3, 4, 5].index(st.session_state.get("search_cols", 3)),
        key="search_cols_selectbox"
    )
    st.session_state["search_cols"] = selected_cols
    
    cols_count = st.session_state["search_cols"]
    cols = st.columns(cols_count) 
    for idx, (_, row) in enumerate(results.iterrows()):
        card_id = row['„Ç´„Éº„ÉâID']
        img_url = f"https://www.onepiece-cardgame.com/images/cardlist/card/{card_id}.png"
        
        with cols[idx % cols_count]: 
            # ‰øÆÊ≠£: Ë©≥Á¥∞expander„ÇíÂâäÈô§„Åó„ÄÅÁîªÂÉè„ÅÆ„Åø„ÇíË°®Á§∫
            st.image(img_url, width='stretch') 

# ===============================
# üß± „Éá„ÉÉ„Ç≠‰ΩúÊàê„É¢„Éº„Éâ
# ===============================
else:
    st.title("üß± „Éá„ÉÉ„Ç≠‰ΩúÊàê„É¢„Éº„Éâ")
    
    # „Çµ„Ç§„Éâ„Éê„ÉºÔºö„Éá„ÉÉ„Ç≠ÊÉÖÂ†±
    st.sidebar.markdown("---")
    st.sidebar.title("üßæ ÁèæÂú®„ÅÆ„Éá„ÉÉ„Ç≠")
    
    leader = st.session_state.get("leader")
    if leader is not None:
        st.sidebar.markdown(f"**„É™„Éº„ÉÄ„Éº:** {leader['„Ç´„Éº„ÉâÂêç']} ({leader['„Ç´„Éº„ÉâID']})")
    
    if leader is not None:
        deck_name_input = st.sidebar.text_input("„Éá„ÉÉ„Ç≠Âêç", value=st.session_state.get("deck_name", ""), key="deck_name_input")
        if deck_name_input != st.session_state.get("deck_name", ""):
            st.session_state["deck_name"] = deck_name_input
    
    total_cards = sum(st.session_state["deck"].values())
    st.sidebar.markdown(f"**ÂêàË®à„Ç´„Éº„Éâ:** {total_cards}/50")
    
    if st.session_state["deck"]:
        deck_cards = []
        for card_id, count in st.session_state["deck"].items():
            card_row = df[df["„Ç´„Éº„ÉâID"] == card_id].iloc[0]
            # „ÇΩ„Éº„Éà„Ç≠„Éº„ÇíÂÜçË®àÁÆó (ÂÖÉ„ÅÆ„Ç≥„Éº„Éâ„ÅÆ„ÇΩ„Éº„Éà„Ç≠„ÉºÂèñÂæó„É≠„Ç∏„ÉÉ„ÇØ„Å´Âêà„Çè„Åõ„Çã)
            base_priority, type_rank, sub_priority, multi_flag = card_row["„ÇΩ„Éº„Éà„Ç≠„Éº"]
            deck_cards.append({
                "card_id": card_id,
                "count": count,
                "new_sort_key": (type_rank, card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"], base_priority, card_id), 
                "cost": card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"],
                "name": card_row["„Ç´„Éº„ÉâÂêç"]
            })
        
        # üí° „ÇΩ„Éº„Éà„Ç≠„Éº„ÄÅ„Ç≥„Çπ„Éà„ÄÅ„Ç´„Éº„ÉâID„Åß„ÇΩ„Éº„Éà
        deck_cards.sort(key=lambda x: x["new_sort_key"])
        
        for card_info in deck_cards:
            
            # üí° „Ç≥„É≥„Éë„ÇØ„ÉàË°®Á§∫: ÂêçÂâç(4) / +„Éú„Çø„É≥(1) / -„Éú„Çø„É≥(1)
            col_name, col_add, col_del = st.sidebar.columns([4, 1, 1])
            
            current = st.session_state["deck"].get(card_info['card_id'], 0)
            is_unlimited = card_info['card_id'] in UNLIMITED_CARDS
            
            with col_name:
                # ÂêçÂâç„Å®ÊûöÊï∞„ÄÅID„Çí„Ç≥„É≥„Éë„ÇØ„Éà„Å´Ë°®Á§∫
                st.markdown(f"**{card_info['name']}** x {card_info['count']} *<small>({card_info['card_id']})</small>*", unsafe_allow_html=True)
            
            with col_add:
                if st.button("Ôºã", key=f"add_sidebar_{card_info['card_id']}", width='stretch', 
                             disabled=(not is_unlimited and current >= 4)):
                    if is_unlimited or current < 4:
                        st.session_state["deck"][card_info['card_id']] = current + 1
                        st.rerun()
            with col_del:
                if st.button("‚àí", key=f"del_{card_info['card_id']}", width='stretch', 
                             disabled=current == 0):
                    if st.session_state["deck"].get(card_info['card_id'], 0) > 0:
                        if st.session_state["deck"][card_info['card_id']] > 1:
                            st.session_state["deck"][card_info['card_id']] -= 1
                        else:
                            del st.session_state["deck"][card_info['card_id']]
                        st.rerun()
            
            st.sidebar.markdown("---")
    
    if total_cards > 50:
        st.sidebar.error("‚ö†Ô∏è 50Êûö„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„ÅôÔºÅ")
    elif total_cards < 50:
        st.sidebar.info(f"ÊÆã„Çä {50 - total_cards} Êûö„ÇíËøΩÂä†„Åß„Åç„Åæ„Åô„ÄÇ")
    else:
        st.sidebar.success("‚úÖ „Éá„ÉÉ„Ç≠„ÅåÂÆåÊàê„Åó„Åæ„Åó„ÅüÔºÅ")
    
    # „Éá„ÉÉ„Ç≠ÁÆ°ÁêÜ
    st.sidebar.markdown("---")
    st.sidebar.subheader("üíæ „Éá„ÉÉ„Ç≠ÁÆ°ÁêÜ")
    
    if leader is not None and st.sidebar.button("üëÅÔ∏è „Éá„ÉÉ„Ç≠„Éó„É¨„Éì„É•„Éº", key="preview_btn"):
        st.session_state["deck_view"] = "preview"
        st.rerun()
    
    SAVE_DIR = "saved_decks"
    os.makedirs(SAVE_DIR, exist_ok=True)
    
    # „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ©üËÉΩÔºà„É≠„Ç∏„ÉÉ„ÇØ‰øÆÊ≠£„Å™„ÅóÔºâ
    if st.sidebar.button("üì§ „Éá„ÉÉ„Ç≠„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà"):
        if leader is None:
            st.sidebar.warning("„É™„Éº„ÉÄ„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        else:
            export_lines = []
            if st.session_state["deck_name"]:
                export_lines.append(f"# {st.session_state['deck_name']}")
            export_lines.append(f"1x{leader['„Ç´„Éº„ÉâID']}")
            
            deck_cards_sorted = []
            for card_id, count in st.session_state["deck"].items():
                card_row = df[df["„Ç´„Éº„ÉâID"] == card_id].iloc[0]
                base_priority, type_rank, _, _ = card_row["„ÇΩ„Éº„Éà„Ç≠„Éº"]
                deck_cards_sorted.append({
                    "card_id": card_id,
                    "count": count,
                    "new_sort_key": (type_rank, card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"], base_priority, card_id),
                })
            deck_cards_sorted.sort(key=lambda x: x["new_sort_key"])
            
            for card_info in deck_cards_sorted:
                export_lines.append(f"{card_info['count']}x{card_info['card_id']}")
            
            export_text = "\n".join(export_lines)
            st.sidebar.text_area("„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„Åü„Éá„ÉÉ„Ç≠", export_text, height=200)
            st.sidebar.download_button(
                label="üì• „ÉÜ„Ç≠„Çπ„Éà„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ",
                data=export_text,
                file_name=f"{st.session_state['deck_name']}_export.txt" if st.session_state["deck_name"] else "deck_export.txt",
                mime="text/plain"
            )
    
    # „Éá„ÉÉ„Ç≠ÁîªÂÉèÁîüÊàê („Ç≠„É£„ÉÉ„Ç∑„É•„ÅÆ„Åä„Åã„Åí„ÅßÈ´òÈÄüÂåñ)
    if st.sidebar.button("üñºÔ∏è „Éá„ÉÉ„Ç≠ÁîªÂÉè„ÇíÁîüÊàê"):
        if leader is None:
            st.sidebar.warning("„É™„Éº„ÉÄ„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        else:
            with st.spinner("ÁîªÂÉè„ÇíÁîüÊàê‰∏≠...ÔºàÂàùÂõû„ÅØÊôÇÈñì„Åå„Åã„Åã„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ2ÂõûÁõÆ‰ª•Èôç„ÅØÈ´òÈÄü„Åß„ÅôÔºâ"):
                deck_name = st.session_state.get("deck_name", "")
                deck_img = create_deck_image(leader, st.session_state["deck"], df, deck_name)
                buf = io.BytesIO()
                deck_img.save(buf, format="PNG")
                buf.seek(0)
                # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
                st.sidebar.image(deck_img, caption="„Éá„ÉÉ„Ç≠ÁîªÂÉèÔºàQR„Ç≥„Éº„Éâ‰ªò„ÅçÔºâ", width='stretch') 
                
                file_name = f"{deck_name}_deck.png" if deck_name else "deck_image.png"
                st.sidebar.download_button(
                    label="üì• ÁîªÂÉè„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ",
                    data=buf,
                    file_name=file_name,
                    mime="image/png"
                )
    
    # „Ç§„É≥„Éù„Éº„ÉàÊ©üËÉΩÔºà„É≠„Ç∏„ÉÉ„ÇØ‰øÆÊ≠£„Å™„ÅóÔºâ
    st.sidebar.markdown("---")
    st.sidebar.subheader("üì• „Éá„ÉÉ„Ç≠„Çí„Ç§„É≥„Éù„Éº„Éà")
    
    st.sidebar.markdown("**QR„Ç≥„Éº„ÉâÁîªÂÉè„Åã„Çâ„Ç§„É≥„Éù„Éº„Éà**")
    uploaded_qr = st.sidebar.file_uploader(
        "QR„Ç≥„Éº„ÉâÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ", 
        type=["png", "jpg", "jpeg"], 
        key=f"qr_upload_{st.session_state['qr_upload_key']}"
    )
    
    if uploaded_qr is not None:
        try:
            from pyzbar.pyzbar import decode
            
            qr_image = Image.open(uploaded_qr)
            decoded_objects = decode(qr_image)
            
            if decoded_objects:
                qr_data = decoded_objects[0].data.decode('utf-8')
                st.sidebar.success("QR„Ç≥„Éº„Éâ„ÇíË™≠„ÅøÂèñ„Çä„Åæ„Åó„ÅüÔºÅ")
                
                lines = [line.strip() for line in qr_data.strip().split("\n") if line.strip()]
                
                imported_deck_name = ""
                start_idx = 0
                if lines and lines[0].startswith("#"):
                    imported_deck_name = lines[0][1:].strip()
                    start_idx = 1
                
                if start_idx < len(lines):
                    first_line = lines[start_idx]
                    
                    if "x" not in first_line:
                        raise ValueError("„Éá„ÉÉ„Ç≠„É™„Çπ„ÉàÂΩ¢Âºè„Åå‰∏çÊ≠£„Åß„ÅôÔºà„É™„Éº„ÉÄ„ÉºË°å„Å´'x'„Åå„Å™„ÅÑÔºâ„ÄÇ")
                        
                    leader_count, leader_id = first_line.split("x")
                        
                    leader_row = df[df["„Ç´„Éº„ÉâID"] == leader_id]
                    if not leader_row.empty:
                        st.session_state["leader"] = leader_row.iloc[0].to_dict()
                        st.session_state["deck"] = {}
                        st.session_state["deck_name"] = imported_deck_name
                        
                        for line in lines[start_idx + 1:]:
                            if "x" in line:
                                count, card_id = line.split("x")
                                count = int(count)
                                if card_id in df["„Ç´„Éº„ÉâID"].values:
                                    st.session_state["deck"][card_id] = count
                        
                        st.session_state["deck_view"] = "preview"
                        st.sidebar.success("„Éá„ÉÉ„Ç≠„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ")
                        st.session_state["qr_upload_key"] += 1 
                        st.rerun()
                    else:
                        st.sidebar.error(f"„É™„Éº„ÉÄ„Éº„Ç´„Éº„Éâ {leader_id} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ")
                else:
                    st.sidebar.error("„Éá„ÉÉ„Ç≠„É™„Çπ„Éà„ÅåÁ©∫„Åã„ÄÅ„É™„Éº„ÉÄ„Éº„ÅåÁâπÂÆö„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ")
            else:
                st.sidebar.warning("QR„Ç≥„Éº„Éâ„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ")
        except ImportError:
            st.sidebar.error("QR„Ç≥„Éº„ÉâË™≠„ÅøÂèñ„Çä„Å´„ÅØ pyzbar „É©„Ç§„Éñ„É©„É™„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ\n`pip install pyzbar` „Åß„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        except Exception as e:
            st.sidebar.error(f"QR„Ç≥„Éº„ÉâË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº: {str(e)}")
    
    st.sidebar.markdown("---")
    st.sidebar.subheader("üì• „Éá„ÉÉ„Ç≠„Çí„Ç§„É≥„Éù„Éº„Éà")
    
    st.sidebar.markdown("**„ÉÜ„Ç≠„Çπ„Éà„Åã„Çâ„Ç§„É≥„Éù„Éº„Éà**")
    import_text = st.sidebar.text_area("„Éá„ÉÉ„Ç≠„É™„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë", height=150, placeholder="1xOP03-040\n4xOP01-088\n...")
    
    if st.sidebar.button("üì• „Ç§„É≥„Éù„Éº„ÉàÂÆüË°å"):
        if not import_text.strip():
            st.sidebar.warning("„Éá„ÉÉ„Ç≠„É™„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        else:
            try:
                lines = [line.strip() for line in import_text.strip().split("\n") if line.strip()]
                if not lines:
                    st.sidebar.error("ÊúâÂäπ„Å™„Éá„ÉÉ„Ç≠„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ")
                else:
                    start_idx = 0
                    imported_deck_name = ""
                    if lines[0].startswith("#"):
                        imported_deck_name = lines[0][1:].strip()
                        start_idx = 1
                    
                    if start_idx < len(lines):
                        first_line = lines[start_idx]
                        if "x" not in first_line:
                             raise ValueError("„Éá„ÉÉ„Ç≠„É™„Çπ„ÉàÂΩ¢Âºè„Åå‰∏çÊ≠£„Åß„ÅôÔºà„É™„Éº„ÉÄ„ÉºË°å„Å´'x'„Åå„Å™„ÅÑÔºâ„ÄÇ")
                             
                        leader_count, leader_id = first_line.split("x")
                             
                        leader_row = df[df["„Ç´„Éº„ÉâID"] == leader_id]
                        if leader_row.empty:
                            st.sidebar.error(f"„É™„Éº„ÉÄ„Éº„Ç´„Éº„Éâ {leader_id} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ")
                        else:
                            st.session_state["leader"] = leader_row.iloc[0].to_dict()
                            st.session_state["deck"] = {}
                            st.session_state["deck_name"] = imported_deck_name
                            
                            for line in lines[start_idx + 1:]:
                                if "x" in line:
                                    count, card_id = line.split("x")
                                    count = int(count)
                                    card_row = df[df["„Ç´„Éº„ÉâID"] == card_id]
                                    if not card_row.empty:
                                        st.session_state["deck"][card_id] = count
                            
                            st.session_state["deck_view"] = "preview"
                            st.sidebar.success("„Éá„ÉÉ„Ç≠„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ")
                            st.rerun()
            except Exception as e:
                st.sidebar.error(f"„Ç§„É≥„Éù„Éº„Éà„Ç®„É©„Éº: {str(e)}")
    
    # „É≠„Éº„Ç´„É´‰øùÂ≠ò„ÉªË™≠ËæºÔºà„É≠„Ç∏„ÉÉ„ÇØ‰øÆÊ≠£„Å™„ÅóÔºâ
    st.sidebar.markdown("---")
    st.sidebar.subheader("üíæ „É≠„Éº„Ç´„É´‰øùÂ≠ò")
    
    current_deck_name = st.session_state.get("deck_name", "")
    
    if st.sidebar.button("üíæ „Éá„ÉÉ„Ç≠„Çí‰øùÂ≠ò"):
        if not current_deck_name:
            st.sidebar.warning("„Éá„ÉÉ„Ç≠Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        elif leader is None:
            st.sidebar.warning("„É™„Éº„ÉÄ„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        else:
            save_lines = []
            if current_deck_name:
                save_lines.append(f"# {current_deck_name}")
            save_lines.append(f"1x{leader['„Ç´„Éº„ÉâID']}")
            
            deck_cards_sorted = []
            for card_id, count in st.session_state["deck"].items():
                card_row = df[df["„Ç´„Éº„ÉâID"] == card_id].iloc[0]
                base_priority, type_rank, _, _ = card_row["„ÇΩ„Éº„Éà„Ç≠„Éº"]
                deck_cards_sorted.append({
                    "card_id": card_id,
                    "count": count,
                    "new_sort_key": (type_rank, card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"], base_priority, card_id),
                })
            deck_cards_sorted.sort(key=lambda x: x["new_sort_key"])
            
            for card_info in deck_cards_sorted:
                save_lines.append(f"{card_info['count']}x{card_info['card_id']}")
                
            save_text = "\n".join(save_lines)
            
            path = os.path.join(SAVE_DIR, f"{current_deck_name}.txt")
            with open(path, "w", encoding="utf-8") as f:
                f.write(save_text)
            st.sidebar.success(f"„Éá„ÉÉ„Ç≠„Äå{current_deck_name}„Äç„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇ")
    
    saved_files = [f[:-4] for f in os.listdir(SAVE_DIR) if f.endswith(".txt")]
    selected_load = st.sidebar.selectbox("üìÇ ‰øùÂ≠òÊ∏à„Åø„Éá„ÉÉ„Ç≠„ÇíË™≠„ÅøËæº„Åø", ["ÈÅ∏Êäû„Å™„Åó"] + saved_files)
    
    if selected_load != "ÈÅ∏Êäû„Å™„Åó":
        if st.sidebar.button("üì• Ë™≠„ÅøËæº„ÇÄ"):
            path = os.path.join(SAVE_DIR, f"{selected_load}.txt")
            try:
                with open(path, "r", encoding="utf-8") as f:
                    loaded_text = f.read()
            except FileNotFoundError:
                st.sidebar.error(f"„Éï„Ç°„Ç§„É´ {selected_load}.txt „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ")
                st.rerun()
                
            lines = [line.strip() for line in loaded_text.strip().split("\n") if line.strip()]
            
            imported_deck_name = ""
            start_idx = 0
            if lines and lines[0].startswith("#"):
                imported_deck_name = lines[0][1:].strip()
                start_idx = 1
            
            if start_idx < len(lines):
                first_line = lines[start_idx]
                if "x" not in first_line:
                    st.sidebar.error("Ë™≠„ÅøËæº„Åø„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ")
                    st.rerun()

                leader_count, leader_id = first_line.split("x")
                leader_row = df[df["„Ç´„Éº„ÉâID"] == leader_id]
                if not leader_row.empty:
                    st.session_state["leader"] = leader_row.iloc[0].to_dict()
                    st.session_state["deck"] = {}
                    st.session_state["deck_name"] = imported_deck_name
                    
                    for line in lines[start_idx + 1:]:
                        if "x" in line:
                            count, card_id = line.split("x")
                            count = int(count)
                            if card_id in df["„Ç´„Éº„ÉâID"].values:
                                st.session_state["deck"][card_id] = count
                    
                    st.session_state["deck_view"] = "preview"
                    st.sidebar.success(f"„Éá„ÉÉ„Ç≠„Äå{selected_load}„Äç„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü„ÄÇ")
                    st.rerun()
                else:
                    st.sidebar.error(f"„É™„Éº„ÉÄ„Éº„Ç´„Éº„Éâ {leader_id} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ")
                    st.rerun()
            else:
                st.sidebar.error("Ë™≠„ÅøËæº„Åø„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ")
                st.rerun()
    
    # „É°„Ç§„É≥„Ç®„É™„Ç¢Ôºö„É™„Éº„ÉÄ„ÉºÈÅ∏Êäû / „Éá„ÉÉ„Ç≠„Éó„É¨„Éì„É•„Éº / „Ç´„Éº„ÉâËøΩÂä†
    if st.session_state["deck_view"] == "leader" or st.session_state["leader"] is None:
        st.subheader("‚ë† „É™„Éº„ÉÄ„Éº„ÇíÈÅ∏Êäû")
        leaders = df[df["„Çø„Ç§„Éó"] == "LEADER"]
        
        leaders = leaders.sort_values(by=["„ÇΩ„Éº„Éà„Ç≠„Éº", "„Ç≥„Çπ„ÉàÊï∞ÂÄ§", "„Ç´„Éº„ÉâID"], ascending=[True, True, True])
        
        cols = st.columns(3)
        for idx, (_, row) in enumerate(leaders.iterrows()):
            img_url = f"https://www.onepiece-cardgame.com/images/cardlist/card/{row['„Ç´„Éº„ÉâID']}.png"
            with cols[idx % 3]:
                # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
                st.image(img_url, caption=row["„Ç´„Éº„ÉâÂêç"], width='stretch') 
                if st.button(f"ÈÅ∏Êäû", key=f"leader_{row['„Ç´„Éº„ÉâID']}"):
                    st.session_state["leader"] = row.to_dict()
                    st.session_state["deck"].clear()
                    st.session_state["deck_name"] = ""
                    st.session_state["deck_view"] = "preview"
                    st.rerun()
    
    elif st.session_state["deck_view"] == "preview":
        leader = st.session_state["leader"]
        
        st.subheader("üÉè „Éá„ÉÉ„Ç≠„Éó„É¨„Éì„É•„Éº")
        
        # „É™„Éº„ÉÄ„ÉºË°®Á§∫
        col1, col2 = st.columns([1, 3])
        with col1:
            leader_img_url = f"https://www.onepiece-cardgame.com/images/cardlist/card/{leader['„Ç´„Éº„ÉâID']}.png"
            # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
            st.image(leader_img_url, width='stretch') 
        with col2:
            st.markdown(f"**{leader['„Ç´„Éº„ÉâÂêç']}**")
            st.markdown(f"Ëâ≤: {leader['Ëâ≤']}")
            st.markdown(f"„Ç´„Éº„ÉâID: {leader['„Ç´„Éº„ÉâID']}")
            if st.button("üîÑ „É™„Éº„ÉÄ„Éº„ÇíÂ§âÊõ¥"):
                st.session_state["leader"] = None
                st.session_state["deck"].clear()
                st.session_state["deck_view"] = "leader"
                if "deck_results" in st.session_state:
                    del st.session_state["deck_results"]
                st.rerun()
        
        st.markdown("---")
        
        # „Éá„ÉÉ„Ç≠„Ç´„Éº„ÉâË°®Á§∫
        st.markdown("### „Éá„ÉÉ„Ç≠ÂÜÖ„ÅÆ„Ç´„Éº„Éâ")
        if st.session_state["deck"]:
            deck_cards_sorted = []
            for card_id, count in st.session_state["deck"].items():
                card_row = df[df["„Ç´„Éº„ÉâID"] == card_id].iloc[0]
                base_priority, type_rank, sub_priority, multi_flag = card_row["„ÇΩ„Éº„Éà„Ç≠„Éº"]
                deck_cards_sorted.append({
                    "card_id": card_id,
                    "count": count,
                    "new_sort_key": (type_rank, card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"], base_priority, card_id),
                    "cost": card_row["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"],
                    "name": card_row["„Ç´„Éº„ÉâÂêç"]
                })
            
            deck_cards_sorted.sort(key=lambda x: x["new_sort_key"])
            
            deck_cols = st.columns(5)
            col_idx = 0
            for card_info in deck_cards_sorted:
                card_img_url = f"https://www.onepiece-cardgame.com/images/cardlist/card/{card_info['card_id']}.png"
                
                with deck_cols[col_idx % 5]:
                    # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
                    st.image(card_img_url, caption=f"{card_info['name']} √ó {card_info['count']}", width='stretch') 
                col_idx += 1
                
                # 5Êûö„Åî„Å®„Å´ÊîπË°å
                if col_idx % 5 == 0:
                     if col_idx < len(deck_cards_sorted) :
                         deck_cols = st.columns(5)
                         
        else:
            st.info("„Éá„ÉÉ„Ç≠„Å´„Ç´„Éº„Éâ„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
        
        st.markdown("---")
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button("‚ûï „Ç´„Éº„Éâ„ÇíËøΩÂä†", key="add_card_btn", type="primary"):
                st.session_state["deck_view"] = "add_cards"
                st.rerun()
        with col2:
            if st.button("üîô „É™„Éº„ÉÄ„ÉºÈÅ∏Êäû„Å´Êàª„Çã", key="back_to_leader_btn"):
                st.session_state["leader"] = None
                st.session_state["deck"].clear()
                st.session_state["deck_view"] = "leader"
                if "deck_results" in st.session_state:
                    del st.session_state["deck_results"]
                st.rerun()
    
    else:
        # ‚ë¢ „Ç´„Éº„ÉâËøΩÂä†ÁîªÈù¢ÔºàÊ§úÁ¥¢„Éï„Ç£„É´„Çø„ÇíÊã°ÂºµÔºâ
        leader = st.session_state["leader"]
        leader_color_text = leader["Ëâ≤"]
        leader_colors = [c.strip() for c in leader_color_text.replace("Ôºè", "/").split("/") if c.strip()]
        
        st.subheader("‚ûï „Ç´„Éº„Éâ„ÇíËøΩÂä†")
        st.info(f"„É™„Éº„ÉÄ„Éº: {leader['„Ç´„Éº„ÉâÂêç']}Ôºà{leader_color_text}Ôºâ - **„É™„Éº„ÉÄ„Éº„ÅÆËâ≤„Å®Âêå„Åò„Ç´„Éº„Éâ„ÅÆ„Åø„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ**")
        
        if st.button("üîô „Éó„É¨„Éì„É•„Éº„Å´Êàª„Çã", key="back_to_preview_btn"):
            st.session_state["deck_view"] = "preview"
            st.rerun()
            
        st.markdown("---")
        
        st.subheader("üîç „Ç´„Éº„ÉâÊ§úÁ¥¢„Éï„Ç£„É´„Çø")
        
        # Êó¢Â≠ò„ÅÆ„Éï„Ç£„É´„ÇøÁä∂ÊÖã„ÇíÂèñÂæó
        current_filter = st.session_state["deck_filter"]

        # UI„ÅÆÂÜçÊßãÁØâÔºö„Ç´„Éº„ÉâÊ§úÁ¥¢„É¢„Éº„Éâ„Å®ÂêåÁ≠â„ÅÆ„Éï„Ç£„É´„Çø
        col_a, col_b, col_c = st.columns(3)
        with col_a:
            # üí° ‰øÆÊ≠£: default=[] „Å´„Çà„ÇäÂàùÊúüÈÅ∏Êäû„Çí„Å™„Åó„Å´„Åô„Çã
            deck_types = st.multiselect("„Çø„Ç§„Éó", ["CHARACTER", "EVENT", "STAGE"], default=current_filter["types"], key="deck_types")
            deck_costs = st.multiselect("„Ç≥„Çπ„Éà", sorted(df["„Ç≥„Çπ„ÉàÊï∞ÂÄ§"].unique()), default=current_filter["costs"], key="deck_costs")
        with col_b:
            deck_counters = st.multiselect("„Ç´„Ç¶„É≥„Çø„Éº", sorted(df["„Ç´„Ç¶„É≥„Çø„Éº"].unique()), default=current_filter["counters"], key="deck_counters")
            all_deck_attributes = sorted({attr for lst in df["Â±ûÊÄß„É™„Çπ„Éà"] for attr in lst if attr})
            deck_attributes = st.multiselect("Â±ûÊÄß", all_deck_attributes, default=current_filter["attributes"], key="deck_attributes")
        with col_c:
            all_deck_features = sorted({f for lst in df["ÁâπÂæ¥„É™„Çπ„Éà"] for f in lst if f})
            deck_features = st.multiselect("ÁâπÂæ¥", all_deck_features, default=current_filter["features"], key="deck_features")
            all_series_ids = sorted([s for s in df["„Ç∑„É™„Éº„Ç∫ID"].unique() if s != "-"])
            deck_series_ids = st.multiselect("ÂÖ•Êâã„Ç∑„É™„Éº„Ç∫", all_series_ids, default=current_filter["series_ids"], key="deck_series_ids")
            
        # 1Ë°å„ÅßÈÖçÁΩÆ
        col_d, col_e = st.columns([3, 1])
        with col_d:
            deck_free = st.text_input("„Éï„É™„Éº„ÉØ„Éº„ÉâÔºà„Ç´„Éº„ÉâÂêç/ÁâπÂæ¥/„ÉÜ„Ç≠„Çπ„Éà/„Éà„É™„Ç¨„ÉºÔºâ", value=current_filter["free_words"], key="deck_free")
        with col_e:
            deck_blocks = st.multiselect("„Éñ„É≠„ÉÉ„ÇØ„Ç¢„Ç§„Ç≥„É≥", sorted(df["„Éñ„É≠„ÉÉ„ÇØ„Ç¢„Ç§„Ç≥„É≥"].unique()), default=current_filter["blocks"], key="deck_blocks")

        # üí° ‰øÆÊ≠£: „ÄåÁµû„ÇäËæº„ÅøÂÆüË°å„Äç„Éú„Çø„É≥„ÇíÂâäÈô§„Åó„ÄÅ„Éï„Ç£„É´„ÇøÁä∂ÊÖã„ÅÆÊõ¥Êñ∞„Å®Ê§úÁ¥¢„ÇíÂ∏∏ÊôÇÂÆüË°å„Åô„Çã
        
        # „Éï„Ç£„É´„ÇøÁä∂ÊÖã„ÅÆÊõ¥Êñ∞
        st.session_state["deck_filter"] = {
            "colors": [], # „É™„Éº„ÉÄ„ÉºËâ≤„ÅßÁµû„Çâ„Çå„Çã„Åü„ÇÅÁ©∫
            "types": deck_types,
            "costs": deck_costs,
            "counters": deck_counters,
            "attributes": deck_attributes,
            "blocks": deck_blocks,
            "features": deck_features,
            "series_ids": deck_series_ids,
            "free_words": deck_free
        }
        
        # „Éï„Ç£„É´„Çø„ÅÆËá™ÂãïÈÅ©Áî®
        st.session_state["deck_results"] = filter_cards(
            df, 
            colors=[], # „É™„Éº„ÉÄ„Éº„ÅÆËâ≤„ÅßËá™ÂãïÁöÑ„Å´„Éï„Ç£„É´„Çø„Åï„Çå„Çã
            types=deck_types, 
            costs=deck_costs, 
            counters=deck_counters, 
            attributes=deck_attributes, 
            blocks=deck_blocks, 
            feature_selected=deck_features, 
            free_words=deck_free, 
            series_ids=deck_series_ids,
            leader_colors=leader_colors # „É™„Éº„ÉÄ„Éº„ÅÆËâ≤„ÇíÊ∏°„Åó„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        )
        
        color_cards = st.session_state["deck_results"]
        
        st.write(f"Ë°®Á§∫‰∏≠„ÅÆ„Ç´„Éº„ÉâÔºö{len(color_cards)} Êûö")
        st.markdown("---")
        
        card_cols = st.columns(5)
        for idx, (_, card) in enumerate(color_cards.iterrows()):
            img_url = f"https://www.onepiece-cardgame.com/images/cardlist/card/{card['„Ç´„Éº„ÉâID']}.png"
            card_id = card["„Ç´„Éº„ÉâID"]
            
            with card_cols[idx % 5]:
                current_count = st.session_state["deck"].get(card_id, 0)
                # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
                st.image(img_url, caption=f"({current_count}/4Êûö)", width='stretch') 
                
                is_unlimited = card_id in UNLIMITED_CARDS
                
                btn_col1, btn_col2 = st.columns(2)
                with btn_col1:
                    # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
                    if st.button("Ôºã", key=f"add_deck_{card_id}_{idx}", type="primary", width='stretch', disabled=(not is_unlimited and current_count >= 4)):
                        count = st.session_state["deck"].get(card_id, 0)
                        if is_unlimited or count < 4:
                            st.session_state["deck"][card_id] = count + 1
                            st.rerun()
                with btn_col2:
                    # üí° width='stretch'„Å´ÁΩÆ„ÅçÊèõ„Åà
                    if st.button("‚àí", key=f"sub_deck_{card_id}_{idx}", width='stretch', disabled=current_count == 0):
                        if card_id in st.session_state["deck"] and st.session_state["deck"][card_id] > 0:
                            if st.session_state["deck"][card_id] > 1:
                                st.session_state["deck"][card_id] -= 1
                            else:
                                del st.session_state["deck"][card_id]
                            st.rerun()
